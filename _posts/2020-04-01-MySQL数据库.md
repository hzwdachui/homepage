---
title: 'MySQL笔记'
date: 2019-09-26
permalink: /posts/2020/04/MySQL笔记/
tags:
  - MySQL
---

# 目录
基础：
- 并发控制
	- 读写锁
	- 锁粒度
- 事务
	- 事务的隔离级别
- 多版本并发控制MVCC

优化MySQL：
- 索引
- 分区
- 复制

经验之谈，MySQL查询优化：
- 通过MySQL的架构分析如何优化查询

# 基础
## 存储引擎
**MySQL逻辑架构:**

- 通用服务层：连接管理，安全性等
- MySQL服务层：和引擎无关的功能（跨存储引擎的功能），包括  查询解析，分析，缓存 / 内置函数，优化器等
- 引擎层：数据的存储和提取（类比操作系统中的文件系统）。上一层通过API和引擎通信，用来真正的执行SQL语句（MySQL服务层解析SQL语句并请求引擎提供的API）

不同存储引擎保存数据和索引的方式不同

## 锁和并发控制
- 并发控制
	- 读写锁
	- 锁粒度
- 事务
	- 事务的隔离级别
- 多版本并发控制MVCC

### 读写锁
最普通的那种，读锁（共享锁）和写锁（排他锁）
处理并发读和写的时候，通过锁来解决问题

**锁粒度：**
- 行锁和表锁（都有共享和排他锁）  
- 为什么需要多种锁粒度？
	- 在**锁的开销**和**安全性**之间实现平衡
	- 表锁：MySQL本身会实现表锁，存储引擎自己也有锁机制。行锁：只有存储引擎来实现（InnoDB有行锁，MyISAM没有）

### MVCC
用于**事务型**存储引擎，存储引擎实现的不是简单的行级锁，可以将MVCC理解为行级锁的变种，但是会减少很多加锁的操作。
具体的实现方式是在每行后保存额外的两列：行的创建时间，行的过期时间（时间指的不是具体时间，而是引擎里记录的每个事务的版本号，每个新的事务都会递增版本号）
仅仅可用于**REPEATABLE READ**和**SERIALIZABLE**的隔离级别
关键词： 某个时间点的**快照** 乐观并发控 悲观并发控制


- SELECT: 只查找版本号更早的行，行的删除版本未定义或更晚 
- INSERT: 保存创建版本号为当前版本号
- DELETE: 保存删除版本号为当前版本号
- UPDATE: 等同于INSERT+DELETE操作

### 意向锁
- 表锁
- 当一个事务在需要获取资源的锁定时，如果该资源已经被排他锁占用，则数据库会自动给该事务申请一个该表的意向锁。
- 让行锁和表锁能够共存

### 乐观/悲观锁
- 悲观锁：自动提交，每次获取数据都会加锁
- 乐观锁：
	- 版本号
	- CAS算法：比较值A和内存值，相等的话写入新值B

### 事务的特点
ACID https://zh.wikipedia.org/wiki/ACID
- Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。
- Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设**约束**、触发器、级联回滚等。
- Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括未提交读（Read uncommitted）、提交读（read committed）、可重复读（repeatable read）和串行化（Serializable）。
- Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

### 事务的隔离级别
隔离级别高，不容易出错，但是并发能力会小，开销会高。
- READ UNCOMMITED：很少使用，有脏读问题
- READ COMMITTED：（又叫不可重复读）
- REPEATABLE READ：MySql默认隔离级别，没有脏读问题，同一个事务中每次读操作结果一样。有幻读问题。
- SERIALIZABLE：确保数据的一致性且可以接受没有并发。

Q: 脏读，不可重复读，幻读（没有这些问题称为可串行化 serializable） 
A: 
- 脏读：未提交的事务对其他事务也可见，事务可以读取未提交的数据
- 不可重复读：事务只能读取已提交的数据（某个事务中多次查询可能结果不一样，因为中间有别的事务提交了）
- 幻读：某个事务读取范围时，又有事务插入行，再次查询会出现幻行（**不可重复读主要讲两次查询同一条记录的结果不一样，幻读强调差入和删除**）

Q：可重复读是怎么实现的
A：一个事务在执行过程中可以看到其他事务已经提交的**新**插入的记录（读已经提交的，其实是读早于本事务开始且已经提交的），但是不能看到其他事务对已有记录的更新（即晚于本事务开始的），并且，该事务不要求与其他事务是“可串行化”的。  
通过**行级**共享锁和排他锁可以实现，但是可能出现幻读。
InnoDB使用的方法发是**MVCC并发控制**
在读取事务开始时，系统会给事务一个当前版本号，事务会**读取版本号<=当前版本号的数据**，这时就算另一个事务插入一个数据，并立马提交，新插入这条数据的版本号会比读取事务的版本号高，因此读取事务读的数据还是不会变。

Q: 如何解决在默认使用可重复读隔离级别时出现的幻读
A: **间隙型锁**，对某一行数据进行操作时，MySQL默认会对周围的行数据进行加锁

# 优化
## 索引
### 索引类型

**从数据结构的角度分：**
- Btree：略
- B+tree：略（聚簇索引是通过B+tree实现的，和非聚簇索引的区别在于聚簇索引叶子节点即数据，保证顺序IO。非聚簇索引叶子节点存储数据的指针）
- hash索引：给每个建立了索引的条目(也可能是好几个联合)条目生成一个hash值和其指向数据位置的指针
	- 不支持范围查询(range query)，只支持精确查询。无法排序。不支持部分索引列匹配（要匹配就要匹配建索引时用的所有列）
	- 特点是比较小，这也是快的原因，可能有冲突但是不太大都不影响性能，冲突特别大影响性能可以通过换hash function来解决
	- 不可用MD5，SHA1这种庞大的hash function。因为生成的hash code很长，查询起来慢

**功能上的区别：**
B或B+tree：全值匹配（和索引中所有列）/匹配最左前缀（索引的第一列）；匹配范围/匹配精确；只访问索引的查询（覆盖索引）
hash：不支持的查询类型见上文。使用场景主要是 ***星型*** schema，需要关联很多查找表（？？？）

Q:使用ORM是否还需要关注索引
A:ORM也需要关心索引，因为ORM只能生成合法的查询，但是不能生成最合适的索引的查询

Q:覆盖索引？
A:只查询建立了索引的列，这个时候查询只访问索引，而不用访问整个数据行

### 补充：B+树维护
- 插入：主要是拆分
- 删除：
TODO：为了优化效率也会又旋转操作？？？

**插入**
![](https://images2015.cnblogs.com/blog/990532/201701/990532-20170117134458755-1356536820.png)

**删除**
![](https://images2015.cnblogs.com/blog/990532/201701/990532-20170117135329114-221553173.png)

### 如何建立高性能索引
**为什么用索引：**
- 快速定位到表的某个位置
- 顺序的索引可以快速ORDER BY,GROUP操作
- 覆盖索引（只需要索引就能完成全部查询）

**为什么有这些优点：**
- 扫描的数据量减少，IO次数减少
- 避免排序和临时表（？？？）
- 随机IO变为顺序IO

不合理的索引需要更多的存储空间/需要更多的维护成本 => 性能反而下降
小表没必要，大表效果好，特大表需要分区

**策略：**
- 索引字符串过长：可以只取前缀建索引（前缀取多少的指标是*索引选择性*）
- 多列索引（联合索引）：
	- 为每个列单独创建索引是愚蠢的
	- 多列索引很重要的一点是优化建立索引的顺序（多列索引按照建索引是SQL语句中的排序来给索引排序），指标也是*索引选择性*，1.一般情况下平均选择性高的排在前面 2.也需要给经常被查询的语句更高的权重
- 去除冗余和重复：索引的维护需要成本，有些代码会重复建立索引（比如设置PRIMARY KEY，UNIQUE和INDEX都会建索引）

**索引在锁机制中的优化：**
- InnoDB会加行锁，索引可以不访问不需要的行，即锁定更少的行
- 减少锁的好处：1. 提高并发性 2. 减少锁造成的开销

Q: 索引选择性?
A: 一个WHERE查询可以对应多少行，选择性高过滤的多（前缀取的越短过滤性肯定越差）

## 复制
### 复制的实现
**为什么复制：**
- 分布式
- 负载均衡
- 备份
- 故障（单点失效）切换

**怎么复制：**
通过**Binary Log**来复制，Binary Log记录的是数据更改的记录，可被翻译成逐条SQL语句
- 主库建立Binary Log，提交事务之前记录事件的更新（按照事务提交顺序）（WAL）
- 备库复制Binary Log到自己的中继日志中并重放事件。**多线程**异步执行。
	- I/O线程和主库连接并复制到**relay log**
	- 二进制转储线程解析Binary Log的线程
	- SQL线程执行复制

### 主从数据库的架构（复制拓扑）
- 异步：master不会管slave的备份进度
	- 可能因为master宕机丢失数据
- 半同步：
	- master保证应答client请求前有至少一个slave写入relay log
	- 仍然有风险：master在等待收到slave的ACK时宕机，可能出现幻读
- 同步：最安全
	- 当slave完成同步以后master才会相应client请求

# 经验之谈：优化数据库查询
## 大家都知道的一些技巧
https://zhuanlan.zhihu.com/p/72855648
- 不能用 select *
- 不使用 NULL 字段
- 合理创建索引
- 为字段选择合适的数据类型

## MySql逻辑架构
![](https://pic4.zhimg.com/80/v2-4d1963141b94fba0b8125dd6a3403153_hd.jpg)
- 客户端层：处理连接，授权认证，安全等
- 服务层：解析，缓存，优化，内置函数（所有跨存储引擎功能）
- 引擎层：提供API：数据存储和提取


## 查询过程
**当我们执行一个查询的时候，MySql做了什么？**

![](https://pic3.zhimg.com/80/v2-3a6399e5da40e092f4029f22725aeb6e_hd.jpg)

**客户端--》查询缓存--》解析--》查询优化--》执行计划（执行引擎）--》返回结果**

**第一步：**
- MySQL客户端/服务端通信协议是“**半双工**”的：
- **客户端**用一个**单独的数据包**将查询请求发送给服务器； **服务器**响应给用户的数据通常会很多，由**多个数据包**组成
	- 所以：尽量保持查询简单且只返回必需的数据，**减小通信间数据包的大小和数量**是一个非常好的习惯，这也是查询中**尽量避免使用SELECT *以及加上LIMIT限制**的原因之一。

**第二步：**
- 如果缓存中有需要的数据，**不执行**之后的步骤
- **写入缓存**和**失效**都消耗资源！
	- 当表结构或数据（例如写操作）变化，缓存失效
- 缓存使用经验：
	- 设计上，小表代替大表
	- 控制缓存空间大小
	- 批量插入代替单条插入

**第三步：解析**
**第四步：查询优化**
- MySql选择的计划其实很可能不是最好的

**第五步：查询执行引擎**
- ``explain + sql`` 语句查看 执行计划
**第六步：返回结果**

## 建立高性能索引
好多。。。是门学问

### 使用覆盖索引：
**如果一个索引包含或者说覆盖所有需要查询的字段的值，那么就没有必要再回表查询，这就称为覆盖索引。**覆盖索引是非常有用的工具，可以极大的提高性能，因为查询只需要扫描索引会带来许多好处：

- 索引条目远小于数据行大小，如果只读取索引，极大减少数据访问量
- 索引是有按照列值顺序存储的，对于I/O密集型的范围查询要比随机从磁盘读取每一行数据的IO要少的多

### 优化冗余和重复索引
### 删除长期未使用索引
### 索引和关联查询
